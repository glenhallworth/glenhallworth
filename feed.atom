<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<link rel="self" href="https://glenhallworth.com/" />
	<id>https://glenhallworth.com/</id>
	<title>Glen Hallworth</title>
	<rights>2018</rights>
	<updated>2018-07-02T23:44:01Z</updated>
	<entry>
		<link href="https://glenhallworth.com/posts/Windows-Service-in-2018" />
		<id>https://glenhallworth.com/posts/Windows-Service-in-2018</id>
		<title>Windows Service in 2018</title>
		<updated>2018-07-02T00:00:00Z</updated>
		<content>&lt;h1 id="windows-service-in-2018"&gt;Windows Service in 2018&lt;/h1&gt;
&lt;p&gt;Most people don't write Windows services anymore. We have the cloud. You can write WebJobs or Functions instead. However in the rare case you have to, say a client with an on-premise server room because their internet connection is awful and a need for background jobs, then this is how I did it.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://topshelf-project.com/"&gt;Topshelf&lt;/a&gt; - To manage the windows service and simplify development.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/fluentscheduler/FluentScheduler"&gt;FluentScheduler&lt;/a&gt; - To schedule jobs.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.thepollyproject.org/"&gt;Polly&lt;/a&gt; - To add resilience and fault handling.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://autofac.org/"&gt;Autofac&lt;/a&gt; - To glue everything together with dependency injection.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://serilog.net/"&gt;Serilog&lt;/a&gt; and &lt;a href="https://getseq.net/"&gt;Seq&lt;/a&gt; - For logging and debugging.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/glenhallworth/WindowsService"&gt;TLDR: Show me the code&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="topshelf"&gt;Topshelf&lt;/h2&gt;
&lt;p&gt;Topshelf makes developing Windows services easy. You develop a console app which you can install as a Windows service. By making testing in development as simple as running a console app, you significantly reduce the feedback loop and ease of development.&lt;/p&gt;
&lt;p&gt;The one caveat is it doesn't support .NET Core yet. There is a develop branch with support. I wouldn't run critical production apps off of it yet. Nevertheless, it should be simple to switch once it does by upgrading the Nuget package and changing the target framework from full framework to .NET Core.&lt;/p&gt;
&lt;h2 id="fluentscheduler"&gt;FluentScheduler&lt;/h2&gt;
&lt;p&gt;I've avoided creating multiple windows services (and thereby many deployment artefacts) by using FluentScheduler.&lt;/p&gt;
&lt;p&gt;You create a job by implementing the IJob interface. Here's a simple job:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    public class TimerJob : IJob
    {
        public void Execute()
        {
            var timer = new System.Timers.Timer(1000) { AutoReset = true };
            timer.Elapsed += (sender, eventArgs) =&amp;gt; Console.WriteLine(&amp;quot;It is {0} and all is well&amp;quot;, DateTime.Now);
            timer.Start();;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You then registry the job by inheriting from Registry class:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt; class TimerRegistry : Registry
    {
        public TimerRegistry(TimerJob job, AppConfig appConfig)
        {
            if (appConfig.RunTimerJob)
            {
                Schedule(job).WithName(job.GetType().FullName).ToRunNow();
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above job runs when the service starts. You can configure when the job runs with a fluent builder. Here's a job that runs every day at 4 AM.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Schedule(job).WithName(job.GetType().FullName).ToRunEvery(1).Days().At(4, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I'm using one registry class per job to keep it clean and separated.&lt;/p&gt;
&lt;h2 id="polly"&gt;Polly&lt;/h2&gt;
&lt;p&gt;In the real world, errors happen, HTTP calls fail, and you want to handle that. Polly adds a level of resilience allowing retry strategies if failures occur.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private async Task ExecuteAsync()
        {
            var policyResult = await Policy
                .Handle&amp;lt;Exception&amp;gt;()
                .RetryAsync(3)
                .ExecuteAndCaptureAsync(async () =&amp;gt;
                {
                    _logger.Information(&amp;quot;Attempting to retrieve&amp;quot;);
                    return await DoThing();
                });

            if (policyResult.Outcome == OutcomeType.Failure)
            {
                _logger.Error(policyResult.FinalException, &amp;quot;Could not retrieve status&amp;quot;);
                return;
            }

            var response = policyResult.Result;
            _logger.Information($&amp;quot;Status is {response}&amp;quot;);
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="autofac"&gt;Autofac&lt;/h2&gt;
&lt;p&gt;I've chosen Autofac for dependency injection. You could use any DI framework. Using assembly scanning I registry all the Jobs and Registries.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;            builder.RegisterAssemblyTypes(TheBackgroundWorker.Assembly)
                .Where(t =&amp;gt; t.IsAssignableTo&amp;lt;IJob&amp;gt;()).AsSelf();

            builder.RegisterAssemblyTypes(TheBackgroundWorker.Assembly)
                .Where(t =&amp;gt; t.IsSubclassOf(typeof(Registry))).As&amp;lt;Registry&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The registry objects injected into BackgroundWorkers which configure FluentScheduler's JobManager.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt; public class BackgroundWorkers
    {
        private readonly IEnumerable&amp;lt;Registry&amp;gt; _registries;

        public BackgroundWorkers(IEnumerable&amp;lt;Registry&amp;gt; registries, ILogger logger)
        {
            _registries = registries;
            JobManager.JobStart += info =&amp;gt; logger.Information($&amp;quot;Scheduled job {info.Name} started&amp;quot;);
            JobManager.JobEnd += info =&amp;gt; logger.Information($&amp;quot;Scheduled job {info.Name} finished&amp;quot;);
            JobManager.JobException += info =&amp;gt;
                logger.Error(info.Exception, $&amp;quot;An error occurred on scheduled job {info.Name}&amp;quot;);
        }

        public void Start()
        {
            JobManager.Initialize(_registries.ToArray());
        }

        public void Stop()
        {
            JobManager.Stop();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally BackgroundWorkers in called by Topshelf when the service is started and stopped.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;		   var backgroundWorkers = container.Resolve&amp;lt;BackgroundWorkers&amp;gt;();
            var rc = HostFactory.Run(x =&amp;gt;
            {
                x.Service&amp;lt;BackgroundWorkers&amp;gt;(s =&amp;gt;
                {
                    s.ConstructUsing(name =&amp;gt; backgroundWorkers);
                    s.WhenStarted(tc =&amp;gt; tc.Start());
                    s.WhenStopped(tc =&amp;gt; tc.Stop());
                });
            });
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="summary"&gt;Summary&lt;/h2&gt;
&lt;p&gt;I have a Windows service that is easy to develop, easy to deploy and easy to add additional jobs to which can be scheduled as required and can be resilient to faults. It is an easy upgrade to .NET Core once Topshelf releases .NET Core version (you can try the preview now). All the sample code which ties all these excellent packages together found at &lt;a href="https://github.com/glenhallworth/WindowsService."&gt;https://github.com/glenhallworth/WindowsService.&lt;/a&gt;&lt;/p&gt;
</content>
		<summary>&lt;p&gt;Most people don't write Windows services anymore. We have the cloud. You can write WebJobs or Functions instead. However in the rare case you have to, say a client with an on-premise server room because their internet connection is awful and a need for background jobs, then this is how I did it.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<link href="https://glenhallworth.com/posts/Downloading-And-Opening-PDF-File-With-Cordova" />
		<id>https://glenhallworth.com/posts/Downloading-And-Opening-PDF-File-With-Cordova</id>
		<title>Downloading and Opening PDF File in Angular Cordova Project</title>
		<updated>2018-01-27T00:00:00Z</updated>
		<content>&lt;p&gt;Rough sample code with opening a PDF file (or any file really) using Cordova.&lt;/p&gt;
&lt;h3 id="plugins"&gt;Plugins&lt;/h3&gt;
&lt;p&gt;This code uses plugins &lt;a href="https://github.com/pwlin/cordova-plugin-file-opener2"&gt;fileOpener2&lt;/a&gt; and &lt;a href="https://github.com/apache/cordova-plugin-file-transfer"&gt;FileTranser&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Typescript"&gt;import { Injectable } from '&amp;#64;angular/core';
import { AuthService } from './auth.service';

declare var FileTransfer: any;

class CallbackToPromise&amp;lt;T&amp;gt; {
    promise: Promise&amp;lt;T&amp;gt;;
    doResolve: (T) =&amp;gt; void;
    doReject: (any?) =&amp;gt; void;
    constructor() {
        this.promise = new Promise&amp;lt;T&amp;gt;((doResolve, doReject) =&amp;gt; {
            this.doResolve = doResolve;
            this.doReject = doReject;
        });
    }
}

&amp;#64;Injectable()
export class DocumentService {
  constructor(private authService: AuthService) {
  }

  downloadDocumentCordova(url: string, fileName: string): Promise&amp;lt;void&amp;gt; {

    const callbackToPromise = new CallbackToPromise&amp;lt;void&amp;gt;();
    const fileTransfer = new FileTransfer();
    const uri = encodeURI(url);
    const fileURL = this.replaceWhitespaceWithUnderscore(window['cordova'].file.dataDirectory + fileName);
    console.log('Starting file download: ' + fileURL);
    fileTransfer.download(
      uri,
      fileURL,
      (entry) =&amp;gt; {
        console.log('File download complete: ' + entry.toURL());
        this.openDocumentCordova(entry.toURL());
        callbackToPromise.doResolve(null);
      },
      (error) =&amp;gt; {
        console.log(`Error occurred downloading file. Code: ${error.code} Source: ${error.source} Target: ${error.target}`);
        callbackToPromise.doReject(error);
      },
      false,
      {
        headers: {
          'Authorization': `Bearer ${this.authService.token}`
        }
      }
    );
    return callbackToPromise.promise;
  }

  private replaceWhitespaceWithUnderscore(str: string) {
    return str.replace(/\s/g, '_', ); // iOS does not like spaces in filenames
  }

  private openDocumentCordova(file: string) {
    window['cordova'].plugins.fileOpener2.open(
      file,
      'application/pdf',
      {
        error: (err) =&amp;gt; {
          console.log('Error opening file. Error status: ' + err.status + ' - Error message: ' + err.message);
        },
        success: () =&amp;gt; {
          console.log('File opened successfully');
        }
      }
    );
  }
}

&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;Rough sample code with opening a PDF file (or any file really) using Cordova.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<link href="https://glenhallworth.com/posts/Telerik-AppBuilder-Alternatives" />
		<id>https://glenhallworth.com/posts/Telerik-AppBuilder-Alternatives</id>
		<title>Telerik AppBuilder Alternatives</title>
		<updated>2017-12-21T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;a href="https://docs.telerik.com/platform/appbuilder/"&gt;Telerik AppBuilder&lt;/a&gt; is being &lt;a href="https://www.telerik.com/platform-next-level"&gt;retired on 10th May, 2018.&lt;/a&gt; It was an easy way to compile Cordova apps for iOS and Android packages without a Mac OS machine. With the Visual Studio plugin, AppBuilder provided a low-friction way to build cross-platform apps. A new platform is required to continue creating these apps due to the impending retirement. We need a tool that allows developers to initiate a build on a windows machine and receive an iOS package in return.&lt;/p&gt;
&lt;h2 id="convert-to-cordova"&gt;Convert to Cordova&lt;/h2&gt;
&lt;p&gt;Telerik AppBuilder based on &lt;a href="https://cordova.apache.org/"&gt;Cordova&lt;/a&gt;, the first step to moving away from AppBuilder will be converting the project into a Cordova project. There will be minimal work to move plugins and platforms over, although Cordova is strict with the &lt;a href="https://cordova.apache.org/docs/en/latest/reference/cordova-cli/"&gt;directory structure&lt;/a&gt;. This initial pain will make it easier moving forward if you want to trial different platforms for app build and release.&lt;/p&gt;
&lt;h2 id="platforms"&gt;Platforms&lt;/h2&gt;
&lt;h3 id="adobe-phonegap"&gt;&lt;a href="https://build.phonegap.com/"&gt;Adobe Phonegap&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id="pros"&gt;Pros&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;a href="https://phonegap.com/products/#phonegap-cli-section"&gt;CLI&lt;/a&gt; is really nice. To initiate a remote build:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;phonegap remote install ios
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The paid plan is $9.99 / month.&lt;/li&gt;
&lt;li&gt;Supports QR Codes in the command line
&lt;img src="https://i.imgur.com/ajpwZlO.png" width="250"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="cons"&gt;Cons&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Lackluster &lt;a href="https://phonegap.com/products/#desktop-app-section"&gt;desktop application&lt;/a&gt; without much functionality.&lt;/li&gt;
&lt;li&gt;The free plan is limited to 1 app.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="monaca"&gt;&lt;a href="https://monaca.io/"&gt;Monaca&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id="pros-1"&gt;Pros&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Has support for &lt;a href="https://github.com/monaca/monaca-cli"&gt;CLI&lt;/a&gt; or &lt;a href="https://monaca.io/localkit.html"&gt;Localkit IDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Can deploy to &lt;a href="https://hockeyapp.net/"&gt;HockeyApp&lt;/a&gt; or &lt;a href="https://deploygate.com/?locale=en"&gt;DeployGate&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://monaca.io/pricing.html"&gt;$20 / month per developer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CLI is easy to use&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;monaca remote build ios
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="cons-1"&gt;Cons&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Discontinued &lt;a href="https://marketplace.visualstudio.com/items?itemName=MonacaandOnsenUI.MonacaforVisualStudio2015"&gt;Visual Studio 2015 plugin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;No Visual Studio 2017 plugin.&lt;/li&gt;
&lt;li&gt;Visual Studio Code extension in development but no release date.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="visual-studio-team-services"&gt;&lt;a href="https://www.visualstudio.com/team-services/"&gt;Visual Studio Team Services&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id="pros-2"&gt;Pros&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Supports &lt;a href="https://blogs.msdn.microsoft.com/devops/2017/11/16/cloud-hosted-mac-agents-for-ci-cd-pipelines/"&gt;hosted Mac OS build agents&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;If hosted agents unsuitable can use &lt;a href="https://www.macincloud.com/"&gt;MacinCloud&lt;/a&gt; build agents or private agents on your machines&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Generic build and release support for applications other than iOS or Android apps such as a backend service.&lt;/li&gt;
&lt;li&gt;Full software development suite: Source Control, Project Management, Build &amp;amp; Release, Testing&lt;/li&gt;
&lt;li&gt;Free, but active development will exhaust free build minutes quickly.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="cons-2"&gt;Cons&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Need to check in to build&lt;/li&gt;
&lt;li&gt;Slow feedback loop&lt;/li&gt;
&lt;li&gt;Need to push app package to a third party for deployment&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="cocoon"&gt;&lt;a href="https://cocoon.io/"&gt;Cocoon&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id="pros-3"&gt;Pros&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Website easy to use with good UX&lt;/li&gt;
&lt;li&gt;Essentially free for development builds&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="cons-3"&gt;Cons&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Poor deployment and automation support
&lt;ul&gt;
&lt;li&gt;Downloads a zip file with packages.&lt;/li&gt;
&lt;li&gt;No straight to phone option.&lt;/li&gt;
&lt;li&gt;No QR Codes.&lt;/li&gt;
&lt;li&gt;No command line tools&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Adds a &amp;quot;Built with Cocoon&amp;quot; splash screen that you can remove for a one-time fee of $500&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="other-platforms"&gt;Other Platforms&lt;/h2&gt;
&lt;h3 id="ionic"&gt;&lt;a href="https://ionicframework.com/"&gt;Ionic&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Ionic is good for building &lt;a href="https://angular.io/"&gt;Angular&lt;/a&gt; based Cordova apps with cloud-build options. It is not suitable using with existing Telerik AppBuilder app due to being tied closely to the Ionic Framework.&lt;/p&gt;
&lt;h3 id="fastlane"&gt;&lt;a href="https://fastlane.tools/"&gt;Fastlane&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Fastlane does not support windows and is out of the scope of this article.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;a href="https://docs.telerik.com/platform/appbuilder/"&gt;Telerik AppBuilder&lt;/a&gt; is being &lt;a href="https://www.telerik.com/platform-next-level"&gt;retired on 10th May, 2018.&lt;/a&gt; It was an easy way to compile Cordova apps for iOS and Android packages without a Mac OS machine. With the Visual Studio plugin, AppBuilder provided a low-friction way to build cross-platform apps. A new platform is required to continue creating these apps due to the impending retirement. We need a tool that allows developers to initiate a build on a windows machine and receive an iOS package in return.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<link href="https://glenhallworth.com/posts/Retrieving-EsriArcGIS-Maps-Token-in-Dotnet-Core" />
		<id>https://glenhallworth.com/posts/Retrieving-EsriArcGIS-Maps-Token-in-Dotnet-Core</id>
		<title>Retrieving Esri/ArcGIS Maps Token in Dotnet Core</title>
		<updated>2017-12-18T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;a href="http://www.esri.com/data/streetmap"&gt;Esri&lt;/a&gt; has a premium service which requires adding a token to REST API requests for services like batch geocoding. The service has a few gotchas. The sample code is:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;    public class EsriTokenResponse
    {
        [JsonProperty(PropertyName = &amp;quot;access_token&amp;quot;)]
        public string AccessToken { get; set; }
        [JsonProperty(PropertyName = &amp;quot;expires_in&amp;quot;)]
        public int ExpiresInMinutes { get; set; }
    }

    public class EsriClient
    {
        private readonly HttpClient _httpClient;
        private readonly string tokenUrl = &amp;quot;https://www.arcgis.com/sharing/rest/oauth2/token&amp;quot;;
        private readonly string clientId = &amp;quot;add_client_id&amp;quot;; // update
        private readonly string clientSecret = &amp;quot;add_client_secret&amp;quot;; // update
        private readonly string grantType = &amp;quot;client_credentials&amp;quot;;
        private readonly int expirationInMinutes = 120;

        public EsriClient(HttpClient httpClient)
        {
            _httpClient = httpClient;
        }
        public async Task&amp;lt;EsriTokenResponse&amp;gt; GetToken()
        {
            var url =
                $&amp;quot;{tokenUrl}?client_id={clientId}&amp;amp;client_secret={clientSecret}&amp;amp;grant_type={grantType}&amp;amp;expiration={ExpirationInMinutes}&amp;quot;;
            var response = await _httpClient.PostAsync(url, null);
            var result =
                await response.Content.ReadAsStringAsync();
            var token = JsonConvert.DeserializeObject&amp;lt;EsriTokenResponse&amp;gt;(result);
            if (string.IsNullOrWhiteSpace(token.AccessToken)) // Esri does not respect HTTP status codes and will always return 200. It puts errors in the body.
            {
                throw new Exception(&amp;quot;Could not retrieve Esri Token&amp;quot;);
            }
            return token;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="gotchas"&gt;Gotchas&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://developers.arcgis.com/documentation/core-concepts/rest-api/"&gt;ArcGIS&lt;/a&gt; has a REST-like API. It doesn't adhere strictly to REST best practices.&lt;/p&gt;
&lt;p&gt;When retrieving the token, I did not expect to put all the parameters into the query string.&lt;/p&gt;
&lt;p&gt;Error handling is more laborious than need be, it always returns HTTP 200 OK. For example, in the case of a bad request, the error details are in the body.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-javascript"&gt;{
    &amp;quot;error&amp;quot;: {
        &amp;quot;code&amp;quot;: 400,
        &amp;quot;error&amp;quot;: &amp;quot;invalid_client_id&amp;quot;,
        &amp;quot;error_description&amp;quot;: &amp;quot;Invalid client_id&amp;quot;,
        &amp;quot;message&amp;quot;: &amp;quot;Invalid client_id&amp;quot;,
        &amp;quot;details&amp;quot;: []
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content>
		<summary>&lt;p&gt;&lt;a href="http://www.esri.com/data/streetmap"&gt;Esri&lt;/a&gt; has a premium service which requires adding a token to REST API requests for services like batch geocoding. The service has a few gotchas. The sample code is:&lt;/p&gt;</summary>
	</entry>
	<entry>
		<link href="https://glenhallworth.com/posts/Dotnet-Core-Templates-To-Hit-The-Ground-Running" />
		<id>https://glenhallworth.com/posts/Dotnet-Core-Templates-To-Hit-The-Ground-Running</id>
		<title>Dotnet Core Templates To Hit The Ground Running</title>
		<updated>2017-11-17T00:00:00Z</updated>
		<content>&lt;p&gt;The problem with starting a new project is there is a lot of boilerplate work to get started. You need to setup project structure, source control, build and release pipelines, dependency injection and logging before you write a line of business code. Dotnet Core 2.0 supports custom templates meaningless boilerplate code to hit the ground running.&lt;/p&gt;
&lt;p&gt;To test creating custom templates I built one for a common app type - C# Web API backend for a single page application. It can be found &lt;a href="https://github.com/glenhallworth/WebApiWithSpa."&gt;https://github.com/glenhallworth/WebApiWithSpa.&lt;/a&gt; I've made it generic including several libraries setup how I like and have left the flexible pieces to be added; such as authentication.&lt;/p&gt;
&lt;p&gt;The templates are distributed using NuGet so it's incredibly easy to use. To get the above template up and running its just two commands:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Install the template from NuGet: dotnet new -i WebApiWithSpa.Template.CSharp&lt;/li&gt;
&lt;li&gt;Create the project: dotnet new WebApiWithSpa&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There is not much to the template, the above template only has three parts to it.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A nuspec file to create a NuGet package.&lt;/li&gt;
&lt;li&gt;A template.json file to config the template.&lt;/li&gt;
&lt;li&gt;The template code files.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/
  WebApiWithSpa.nuspec - The nuspec file to pack the NuGet package.
  content/
    .template.config/ - A folder for template configuration.
      template.json - The template configuration.
    WebApiWithSpa/ - The code to use for the project.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This saves me time setting up new projects as the template has already been setup with all the common aspects for projects of this type. There are always tasks at the beginning of the project which are set and forget - logging being an example.&lt;/p&gt;
&lt;p&gt;The project contains the boilerplate structure of the project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Domain Layer&lt;/em&gt; - The core business logic of an application. Includes IQuery and ICommand interfaces to support CQRS pattern.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Web API Layer&lt;/em&gt; - The API of the application. Has a sample Values controller supporting example CRUD operations. Also has logging with Serilog and static file serving is setup.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Code Gen&lt;/em&gt; - A console application to generate typescript interfaces for the API request/response objects. Makes writing the SPA easier by automating the creation of the API contract. This builds every time the Web API layer builds.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Unit Tests&lt;/em&gt; - A project for unit tests as every project should have unit tests.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Furthermore, you can add optional content to the template to support toggling features on or off. As a future enhancement, I'll add optional authentication setup.&lt;/p&gt;
&lt;p&gt;If you create several .NET projects every year you should consider using templates to save yourself time lowering the barrier to beginning a new project. Incredibly useful if you or your company has a standard project structure and preferred toolset. Not only will you make your project setup quicker because it's so easy to share with other people can benefit from your template.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;The problem with starting a new project is there is a lot of boilerplate work to get started. You need to setup project structure, source control, build and release pipelines, dependency injection and logging before you write a line of business code. Dotnet Core 2.0 supports custom templates meaningless boilerplate code to hit the ground running.&lt;/p&gt;</summary>
	</entry>
	<entry>
		<link href="https://glenhallworth.com/posts/How-to-save-a-webpage-as-PDF-file-and-send-via-email-using-Puppeteer-and-Nodemailer.js" />
		<id>https://glenhallworth.com/posts/How-to-save-a-webpage-as-PDF-file-and-send-via-email-using-Puppeteer-and-Nodemailer.js</id>
		<title>How to save a webpage as PDF file and send via email using Puppeteer and Nodemailer.js</title>
		<updated>2017-10-06T00:00:00Z</updated>
		<content>&lt;pre&gt;&lt;code class="language-javascript"&gt;const puppeteer = require(&amp;quot;puppeteer&amp;quot;);
const nodemailer = require(&amp;quot;nodemailer&amp;quot;);

class Webpage {
  static async generatePDF(url) {
    const browser = await puppeteer.launch({ headless: true }); // Puppeteer can only generate pdf in headless mode.
    const page = await browser.newPage();
    await page.goto(url, {
      waitUntil: &amp;quot;networkidle&amp;quot;,
      networkIdleTimeout: 5000
    }); // Adjust network idle as required.
    const pdfConfig = {
      format: &amp;quot;A4&amp;quot;,
      printBackground: true,
      margin: {
        // Word's default A4 margins
        top: &amp;quot;2.54cm&amp;quot;,
        bottom: &amp;quot;2.54cm&amp;quot;,
        left: &amp;quot;2.54cm&amp;quot;,
        right: &amp;quot;2.54cm&amp;quot;
      }
    };
    await page.emulateMedia(&amp;quot;screen&amp;quot;);
    const pdf = await page.pdf(pdfConfig); // Return the pdf buffer. Useful for saving the file not to disk.

    await browser.close();

    return pdf;
  }
}

class Email {
  static sendEmail(to, subject, text, filename, fileContent) {
    const transporter = nodemailer.createTransport({
      host: &amp;quot;smtp.office365.com&amp;quot;,
      port: 587,
      secureConnection: true, // Used for Office 365
      tls: { ciphers: &amp;quot;SSLv3&amp;quot; }, // Used for Office 365
      auth: {
        user: &amp;quot;user&amp;quot;, // Update username
        pass: &amp;quot;pass&amp;quot; // Update password
      }
    });

    const mailOptions = {
      from: &amp;quot;from&amp;#64;email.com&amp;quot;, // Update from email
      to: to,
      subject: subject,
      text: text,
      attachments: [
        {
          filename: filename,
          content: fileContent
        }
      ]
    };

    transporter.sendMail(mailOptions, (error, info) =&amp;gt; {
      if (error) {
        return console.log(error);
      }

      console.log(&amp;quot;Message sent: %s&amp;quot;, info.messageId);
    });
  }
}

(async () =&amp;gt; {
  const url =
    &amp;quot;https://ia601405.us.archive.org/18/items/alicesadventures19033gut/19033-h/19033-h.htm&amp;quot;;
  const buffer = await Webpage.generatePDF(url);
  Email.sendEmail(
    &amp;quot;to&amp;#64;email.com&amp;quot;, // Update to email
    &amp;quot;Alice in Wonderland&amp;quot;,
    &amp;quot;I thought you might enjoy this book!&amp;quot;,
    &amp;quot;Alice in Wonderland.pdf&amp;quot;,
    buffer
  );
})();
&lt;/code&gt;&lt;/pre&gt;
</content>
	</entry>
	<entry>
		<link href="https://glenhallworth.com/posts/How-to-save-a-webpage-as-PDF-file-using-Puppeteer.js" />
		<id>https://glenhallworth.com/posts/How-to-save-a-webpage-as-PDF-file-using-Puppeteer.js</id>
		<title>How to save a webpage as PDF file using Puppeteer.js</title>
		<updated>2017-10-06T00:00:00Z</updated>
		<content>&lt;pre&gt;&lt;code class="language-javascript"&gt;const puppeteer = require(&amp;quot;puppeteer&amp;quot;);

class Webpage {
  static async generatePDF(url) {
    const browser = await puppeteer.launch({ headless: true }); // Puppeteer can only generate pdf in headless mode.
    const page = await browser.newPage();
    await page.goto(url, {
      waitUntil: &amp;quot;networkidle&amp;quot;,
      networkIdleTimeout: 5000
    }); // Adjust network idle as required.
    const pdfConfig = {
      path: &amp;quot;url.pdf&amp;quot;, // Saves pdf to disk.
      format: &amp;quot;A4&amp;quot;,
      printBackground: true,
      margin: {
        // Word's default A4 margins
        top: &amp;quot;2.54cm&amp;quot;,
        bottom: &amp;quot;2.54cm&amp;quot;,
        left: &amp;quot;2.54cm&amp;quot;,
        right: &amp;quot;2.54cm&amp;quot;
      }
    };
    await page.emulateMedia(&amp;quot;screen&amp;quot;);
    const pdf = await page.pdf(pdfConfig); // Return the pdf buffer. Useful for saving the file not to disk.

    await browser.close();

    return pdf;
  }
}

(async () =&amp;gt; {
  const url =
    &amp;quot;https://ia601405.us.archive.org/18/items/alicesadventures19033gut/19033-h/19033-h.htm&amp;quot;;
  const buffer = await Webpage.generatePDF(url);
})();
&lt;/code&gt;&lt;/pre&gt;
</content>
	</entry>
</feed>